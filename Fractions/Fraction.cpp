#include "Fraction.h"
using namespace mathlib;


	//void mathlib::Fraction<T>::simplify()
	//{

	//}

	//double mathlib::Fraction<T>::toDouble()
	//{
	//	return numerator / denominator;
	//}

	//Fraction<> mathlib::Fraction<T>::operator + (Fraction<T> f2)
	//{
	//	if (denominator == f2.denominator) { return Fraction<>(numerator + f2.numerator, denominator); }

	//	return Fraction<>(1, 1);
	//}

	//Fraction<> mathlib::Fraction<T>::operator - (Fraction<T> f2)
	//{
	//	if (denominator == f2.denominator) { return Fraction<>(numerator - f2.numerator, denominator); }
	//	return Fraction<>(1, 1);
	//}

	//Fraction<> mathlib::Fraction<T>::operator * (Fraction<T> f2)
	//{
	//	return Fraction<>(1, 1);
	//}

	//Fraction<> mathlib::Fraction<T>::operator / (Fraction<T> f2)
	//{
	//	return Fraction<>(1, 1);
	//}


	//bool mathlib::Fraction<T>::operator == (Fraction<T> f2)
	//{
	//	return ((numerator / denominator) == (f2.numerator / f2.denominator));
	//}

	//bool mathlib::Fraction<T>::operator != (Fraction<T> f2)
	//{
	//	return !((numerator / denominator) == (f2.numerator / f2.denominator));
	//}

	//bool mathlib::Fraction<T>::operator > (Fraction<T> f2)
	//{
	//	return ((numerator / denominator) > (f2.numerator / f2.denominator));
	//}

	//bool mathlib::Fraction<T>::operator < (Fraction<T> f2)
	//{
	//	return ((numerator / denominator) < (f2.numerator / f2.denominator));
	//}

	//bool mathlib::Fraction<T>::operator >= (Fraction<T> f2)
	//{
	//	return ((numerator / denominator) >= (f2.numerator / f2.denominator));
	//}

	//bool mathlib::Fraction<T>::operator <= (Fraction<T> f2)
	//{
	//	return((numerator / denominator) <= (f2.numerator / f2.denominator));
	//}

// First + Second
// (f2 = Second)